//Small example of implicit and explicit constructor
#include <iostream>
#include <string>
#include <vector>

class Boo{
    public:
    Boo(){
        name_="Standard";
        booId_=0;
    }
    Boo(std::string name, int id):name_(name),booId_(id){}
    Boo(const Boo & other); //Copy constructor
    explicit Boo(const std::string & name){
        name_=name;
        booId_=999999;
    };//Other constructor
    Boo(const int a){booId_=a;name_="Boo generated by int conversion";}
    
    std::string GetName() const {return name_;}
    int GetId() const  {return booId_;}

    private:
    std::string name_;
    int booId_;
};
Boo::Boo(const Boo & other){
    name_=other.GetName();
    booId_=other.GetId();
}


void getBooExternally_forStringTest(Boo boo){
    std::cout << "name:" <<   boo.GetName() << std::endl;
    std::cout << "id:" <<   boo.GetId() << std::endl;
}
void getBooExternally_forIntTest(Boo boo){
    std::cout << "name:" <<   boo.GetName() << std::endl;
    std::cout << "id:" <<   boo.GetId() << std::endl;
}


int main(){
    // Boo b1("boo1",0);
    // Boo b1_copia(b1); //copy constructor is implicitly called 

    std::string name2 = "Generado con string conversions"; //takes the argument by reference, no by copy like the other. You can not pass a reference to a temporal object
    int id=8;
    Boo b2("boo2");

    //getBooExternally_forStringTest(name2);//The explicit keyword in the Boo(const &string) stop the compiler for do the implic conversion for  the string
    getBooExternally_forStringTest(Boo(name2)); //Thanks to explicit the application code need to explicitely invoke the Constructoor
    getBooExternally_forIntTest(id); //in the constructor that takes a int there is  explicit keyword, the compiler implicitly convert int id into Boo using Boo(const int a)

}